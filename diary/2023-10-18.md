&nbsp;세번째 날에는 상세페이지 API를 구현했습니다.

&nbsp;엔티티 매핑을 하면서 작성한 엔티티가 실제 DB와 일치하는지 확인하기 위해서 단순하게 select 쿼리를 실행해보는 테스트를 추가해봤습니다. 쿼리 로그를 보면서 정상 동작함을 확인할 수 있었고 오타가 있을 때는 테스트가 실패해서 확인이 쉬웠습니다. assert문이 없는 테스트 코드도 디버깅에 도움이 될 수 있다는 것을 느꼈습니다.

&nbsp;다음으로 Repository를 구현하는데 필요한 모든 데이터를 join해서 하나의 쿼리로 가져올지 아니면 조금은 나눠서 가져올지 고민했습니다. 쿼리를 하나로 했을 때 성능 상의 이점을 무시할 수 없다고 생각해서 한 쿼리를 가져오도록 구현했습니다. QueryDSL의 쿼리 결과를 DTO로 매핑할 때 대부분의 시간을 소비한 것 같습니다. @QueryProjection의 사용과 쿼리 결과를 Grouping 처리하는 데 익숙하지 않아서였습니다. left join 쿼리 결과 중복되는 데이터는 queryDSL의 set 메써드를 써서 제거했습니다.

&nbsp;이후에는 Controller를 구현하면서 응답 데이터를 snake_case로 바꿔보기도 하고 200, 404 응답 처리, Swagger 설정, Cors 테스트 설정을 해봤습니다.